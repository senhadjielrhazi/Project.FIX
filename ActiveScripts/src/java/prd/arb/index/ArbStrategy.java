package prd.arb.index;

import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.Set;

import org.marketcetera.core.time.Period;
import org.marketcetera.event.TickEvent;
import org.marketcetera.event.info.InstrumentInfo;
import org.marketcetera.marketdata.Content;
import org.marketcetera.marketdata.DataReferenceKey;
import org.marketcetera.marketdata.MarketDataRequestBuilder;
import org.marketcetera.strategy.java.Strategy;
import org.marketcetera.trade.BrokerID;
import org.marketcetera.trade.ExecutionReport;
import org.marketcetera.trade.Factory;
import org.marketcetera.trade.Instrument;
import org.marketcetera.trade.OrderCancelReject;
import org.marketcetera.trade.OrderID;
import org.marketcetera.trade.OrderSingle;
import org.marketcetera.trade.OrderType;
import org.marketcetera.trade.TimeInForce;
import org.marketcetera.trading.MarketUtil;
import org.marketcetera.trading.arbitrage.index.BrokerEntry;
import org.marketcetera.trading.arbitrage.IBrokerEntry;
import org.marketcetera.trading.arbitrage.IMarketEntry;
import org.marketcetera.trading.arbitrage.IMarketSide;
import org.marketcetera.trading.arbitrage.ITradeEntry;
import org.marketcetera.trading.arbitrage.ITradeSide;
import org.marketcetera.trading.arbitrage.index.MarketEntry;
import org.marketcetera.trading.arbitrage.TradeEntry;
import org.marketcetera.trading.arbitrage.TradeSide;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

/**
 * Strategy that arb market data cross brokers
 */
public class ArbStrategy extends Strategy {
	
	/**
	 * Place holder of all the broker entries
	 */
	private final Map<DataReferenceKey, IBrokerEntry> mDataExch = Maps.newHashMap();
	
	/**
	 * Place holder of all the composite markets
	 */
	private final Map<String, IMarketEntry> mMarketArbs = Maps.newHashMap();
	
	/**
	 * Place holder of all the brokers trades
	 */
	private final Map<DataReferenceKey, ITradeEntry> mTradeExch = Maps.newHashMap();
	
	/**
	 * States the Strategy mode
	 */
    private StrategyMode mStrategyMode = StrategyMode.TR_HALT;
    
    /**
     * Define the strategy execution mode
     */
    private static final AtomicBoolean mExecutionMode = new AtomicBoolean(true);
    
    /**
	 * The EMA bid/ask spread multiplier
	 */
	private final static double TRADE_BIDASK_MULT = 0.20;//0.35
	
	/**
	 * The EMA slippage multiplier
	 */
	private final static double TRADE_SLIPPAGE_MULT = 1.25;//2.0
	
	/**
	 * The minimum pnl when trading opt mode
	 */
	private final static double TRADE_PNL_OPTRUN = 0.00003;//0.0001
	
	/**
	 * The minimum pnl when trading pos mode
	 */
	private final static double TRADE_PNL_POSRUN = 0.00001;//0.00003
	
	/**
	 * The threshold for the long/short
	 *  
     *  long score > TRADE_THRESHOLD;
     *  short score < 1 - TRADE_THRESHOLD;
	 */
	private final static double TRADE_SCORE_THRESHOLD = 0.60;
	
	/**
	 * The threshold for the stoploss
	 */
	private final static double TRADE_STOPLOSS_THRESHOLD = 0.0020;//0.002
	
	/**
	 * The maximum number of positions open simultaneously per broker
	 */
	private final static double TRADE_MAX_POSNB = 6;//6
	
	/**
	 * The maximum time allowed for stale data
	 */
	private final static long TRADE_TIME_LAP = 45*1000;
	
	/**
	 * The maximum size of a single trade in USD
	 */
	private final static double TRADE_MAX_SIZE = 100.;
	
	/**
	 * The number of days to track trades done by the strategy
	 */
	private final static Period TRADE_MAX_DAYNB = Period.WEEKLY;
	
	/**
	 * The Id of the strategy
	 */
	private final static String STRATEGY_SUFFIX = "ix";
	
	/**
	 * Place holder of all the broker market entries
	 * 
	 * @return the map
	 */
	private Map<DataReferenceKey, IBrokerEntry> getDataExch()
	{
		return mDataExch;
	}
	
	/**
	 * Place holder of all the market arb entries
	 * 
	 * @return the map
	 */
	private Map<String, IMarketEntry> getMarketArbs()
	{
		return mMarketArbs;
	}
	
	/**
	 * Place holder of all the broker trades entries
	 * 
	 * @return the map
	 */
	private Map<DataReferenceKey, ITradeEntry> getTradeExch()
	{
		return mTradeExch;
	}
	
    /**
     * The string to suffix to the orderIDs generated by this strategy.
     *
     * @return the string to suffix to the orderIDs generated by this strategy.
     */
    public String getIDSuffix() {
        return STRATEGY_SUFFIX;
    }
    
	/**
	 * States the callback reasons
	 */
	private static enum Reason
	{
		TECH_INIT(3*60*1000),
		MD_UPDATE(3*60*1000),
		SYNC_TRADES(30*1000);
		
		/**
	     * Create a new Reason instance.
	     *
	     * @param inDelay
	     */
	    private Reason(long inDelay)
	    {
	    	delay = inDelay;
	    }
	    
		public long getDelay() {
			return delay;
		}

		/**
	     * the delay in ms
	     */
	    private final long delay;
	};
    
	/**
	 * States the Strategy mode
	 */
	private static enum StrategyMode
    {
		TR_HALT,
    	TR_OPTRUN,
    	TR_POSRUN,
		TR_OPSRUN;
    };
    
	/**
	 * Creates the data reference key
	 */
	private static class DataKeyFactory
	{
		static DataReferenceKey createKey(BrokerID brokerID, Instrument instrument)
		{
			return new DataReferenceKey(brokerID, instrument);
		}
		
		static DataReferenceKey createKey(TickEvent inTick)
		{
			return new DataReferenceKey(inTick.getBrokerID(), inTick.getInstrument());
		}
		
		static DataReferenceKey createKey(ExecutionReport inReport)
		{
			return new DataReferenceKey(inReport.getBrokerID(), inReport.getInstrument());
		}
		
		static DataReferenceKey createKey(ITradeSide iTrade)
		{
			return new DataReferenceKey(iTrade.getBrokerID(), iTrade.getInstrument());
		}
	}
	
	/**
     * Gets the report history origin date to use for the order history.
     * 
     * <p>Strategies may override this method to return a date. For performance
     * reasons, it is best to use the most recent date possible. The default is
     * to return the first second of the current day.
     * 
     * <p>All strategies in the same strategy agent share the same order history manager.
     * The report history origin date can be set only by the first strategy to run.
     *
     * @return a <code>Date</code> value
     */
	@Override
    protected final Date getReportHistoryOriginDate()
    {
        Calendar dateGenerator = Calendar.getInstance();
        dateGenerator.set(Calendar.HOUR_OF_DAY,
                          0);
        dateGenerator.set(Calendar.MINUTE,
                          0);
        dateGenerator.set(Calendar.SECOND,
                          0);
        dateGenerator.set(Calendar.MILLISECOND,
                          0);
        
        Date originDate = new Date(dateGenerator.getTime().getTime() 
        							- TRADE_MAX_DAYNB.getInterval());
        return originDate;
    }
	
    /**
     * Executed when the strategy is started.
     * Use this method to set up data flows
     * and other initialization tasks.
     */
    @Override
    public void onStart()
    {
    	warn("ArbStrategy Staring...!");
        
        //Load brokers
        BrokerID[] brokers = MarketUtil.getBrokers(getDataBrokers(), getTradeBrokers());
        
    	//Load instruments and infos
    	for(BrokerID brokerID:brokers){
			Set<Instrument> instruments = getInstruments(brokerID);
			if(instruments != null){
    			for(Instrument instrument:instruments){
    				InstrumentInfo instrumentInfo = getInstrumentInfo(brokerID, instrument);		        				
					DataReferenceKey key = DataKeyFactory.createKey(brokerID, instrument);
    				if(getDataExch().containsKey(key)){
    					throw new IllegalArgumentException("Key alreay in map: Broker= " + brokerID + "; Instrument= " + instrument);
    				}
    				getDataExch().put(key, new BrokerEntry(brokerID, instrument, instrumentInfo, TRADE_BIDASK_MULT, TRADE_SLIPPAGE_MULT));
    				
    				warn("Adding: Broker= " + brokerID + "; Instrument= " + instrument + "; Info= " + instrumentInfo);
    			}
			}
    	}
    	
    	//Build market broker entries
		for(IBrokerEntry entry:getDataExch().values()){
			Instrument instrument = entry.getInstrument();
			
			String symbol = instrument.getSymbol();
			if(!getMarketArbs().containsKey(symbol)){
				getMarketArbs().put(symbol, new MarketEntry(instrument, getDataExch().values(), TRADE_TIME_LAP));
    		}
		}
    	
    	//Load the strategy existing trades
    	Map<OrderID, ExecutionReport> results = getExecutionReports(getIDSuffix());
		for (Entry<OrderID, ExecutionReport> result:results.entrySet()) {
			ExecutionReport report = result.getValue();
			OrderID orderID = result.getKey();
			DataReferenceKey key = DataKeyFactory.createKey(report);
			
			IBrokerEntry brokerEntry = getDataExch().get(key);
			if(brokerEntry != null)
			{
				// Build an order request
		        OrderSingle order = Factory.getInstance().createOrderSingle();
		        order.setOrderID(orderID);
		        order.setOrderType(OrderType.Limit);
		        order.setPrice(report.getPrice());
		        order.setQuantity(report.getOrderQuantity());
		        order.setSide(report.getSide());
		        order.setBrokerID(report.getBrokerID());
		        order.setInstrument(report.getInstrument());
		        order.setTimeInForce(TimeInForce.GoodTillCancel);
		        
				ITradeSide trade = new TradeSide(order, brokerEntry);	
				
				ITradeEntry holder = getTradeExch().get(key);
				if(holder == null){
					holder = new TradeEntry(report.getBrokerID(), report.getInstrument());
					getTradeExch().put(key, holder);
				}
				holder.addTrade(trade);
				holder.onReport(report);
				
				warn("Added trade:" +  trade + "; Entry=" + brokerEntry + "; " + holder.getActiveNB() + "; " + holder.getFilledNB() + "; " + holder.getTrades().size() + "; " + report.getOrderStatus() + "; " + trade.isCancelled() + "; " + trade.isOpened() + "; " + trade.isFilled() + "; " + orderID + "; " + report.getOrderID());
			}else{
				warn("Error finding the brokerEntry for: " + report);
			}
		}
    	
		for(ITradeEntry entry:getTradeExch().values()){
			warn("Exch trade:" +  entry);	
		}
		
    	//Request market data
        for(IBrokerEntry entry:getDataExch().values()){
    		requestMarketData(MarketDataRequestBuilder.newRequest().
                        withInstrument(entry.getInstrument()).
                        withBrokerID(entry.getBrokerID()).
                        withContent(Content.TICK).create());
        }
        
        //Market data analysis setup 
        Reason reason = Reason.TECH_INIT;
        requestCallbackAfter(reason.getDelay(), reason);
    }

    /**
     * Executed when the strategy receives a Tick event.
     *
     * @param inTick the tick event.
     */
    @Override
    public void onTick(TickEvent inTick) 
    {
    	DataReferenceKey key = DataKeyFactory.createKey(inTick);
		IBrokerEntry entry = getDataExch().get(key);
		if(entry != null)
		{
			entry.onTick(inTick);
			
			if(mStrategyMode.equals(StrategyMode.TR_OPTRUN))
			{
				tradeOptRun();
			} else if(mStrategyMode.equals(StrategyMode.TR_POSRUN))
			{
				tradePosRun();
			} else if(mStrategyMode.equals(StrategyMode.TR_OPSRUN))
			{
				tradeOpsRun();
			}
		}
    }
    
	private int mCounter = 0;
	private double mPnL = 0.;
	
    /**
     * Trade any arbs with optimal PnL.
     */
    private void tradeOptRun() 
    {
    	mStrategyMode = StrategyMode.TR_HALT;
    	
    	IMarketSide optBid = null, optAsk = null;
    	double optSize = 0D, optPnL = 0D;
		for(IMarketEntry symMarket : getMarketArbs().values()){
			double tradeSz = getStandardSize(symMarket.getSymbol());
			
			IMarketSide symBid = symMarket.getBid(tradeSz), symAsk = symMarket.getAsk(tradeSz);
			double symPnL = MarketUtil.getPnL(symBid, symAsk);

			if(symBid == null || symAsk == null
					|| symBid.getSize() < tradeSz || symAsk.getSize() < tradeSz
					|| symBid.getTime() < System.currentTimeMillis() - TRADE_TIME_LAP
					|| symAsk.getTime() < System.currentTimeMillis() - TRADE_TIME_LAP){
				continue;
			}

			if(optBid == null || optAsk == null || symPnL > optPnL){
				optBid = symBid; optAsk = symAsk;
				optSize = tradeSz;
				optPnL = symPnL;
			}
		}
		
		//Trade Optimal
		if(optPnL >= TRADE_PNL_OPTRUN && optBid != null && optAsk != null){
			for(ITradeSide trade:MarketUtil.execute(optBid, optAsk, optSize, getIDSuffix())){
				DataReferenceKey key = DataKeyFactory.createKey(trade);
				ITradeEntry holder = getTradeExch().get(key);
				if(holder == null){
					holder = new TradeEntry(trade.getOrder().getBrokerID(), trade.getOrder().getInstrument());
					getTradeExch().put(key, holder);
				}
				holder.addTrade(trade);
				
				warn("OptRun Order=" + trade.getOrder());
				sendOrder(trade.getOrder());
			}
			
			Reason reason = Reason.SYNC_TRADES;
	        requestCallbackAfter(reason.getDelay(), reason);
			warn("OptRun PnL=" + optPnL + "; Bid=" + optBid + "; Ask=" + optAsk);
			return;
		} 
		
		mStrategyMode = StrategyMode.TR_OPTRUN;
    	if(optPnL > 0){//TODO
    		mCounter++; mPnL += optPnL;
			System.out.println("PositiveOpt: " + mCounter + "; TPnL=" + mPnL + "; PnL=" + optPnL + "; Bid=" + optBid + "; Ask=" + optAsk);
		}
    }
    
    /**
     * Trade the current position with optimal PnL.
     */
    private void tradePosRun() 
    {
    	mStrategyMode = StrategyMode.TR_HALT;
    	
    	List<ITradeSide> posTrades = null;
    	double posPnL = 0D;
    	
    	for(ITradeEntry holderA:getTradeExch().values()){
    		List<ITradeSide> tradesA = holderA.getTrades();
    		if(!tradesA.isEmpty()){
	    		ITradeSide tradeA = tradesA.get(0);
				double tradeSz = tradeA.getLeavesQty();
				
	    		for(Entry<DataReferenceKey, ITradeEntry> entryB:getTradeExch().entrySet()){
	    			List<ITradeSide> tradesB = entryB.getValue().getTrades();
	    			DataReferenceKey dataBkey = entryB.getKey();
	    			if(!tradesB.isEmpty()){
		    			ITradeSide tradeB = tradesB.get(0);
						
						IMarketEntry market = getMarketArbs().get(tradeA.getSymbol());
						IMarketSide bid = tradeA.isBuy()?tradeA.getMarket().getBid():market.getBid(tradeSz, dataBkey, tradeB.getSide());
						IMarketSide ask = tradeA.isBuy()?market.getAsk(tradeSz, dataBkey, tradeB.getSide()):tradeA.getMarket().getAsk();
						
						if(bid == null || ask == null
								|| bid.getSize() < tradeSz || ask.getSize() < tradeSz
								|| bid.getTime() < System.currentTimeMillis() - TRADE_TIME_LAP
								|| ask.getTime() < System.currentTimeMillis() - TRADE_TIME_LAP){
							continue;
						}
						
						double symPnL = MarketUtil.getPnL(bid, ask);
						if(posTrades == null || symPnL > posPnL){
							posTrades = MarketUtil.execute(bid, ask, tradeSz, getIDSuffix()); 
							posPnL = symPnL;
						}
    				}
	    		}
    		}
    	}
    	
		//Trade Position
    	if(posPnL >= TRADE_PNL_POSRUN && posTrades != null){			
			for(ITradeSide trade:posTrades){
				DataReferenceKey key = DataKeyFactory.createKey(trade);
				ITradeEntry holder = getTradeExch().get(key);
				if(holder == null){
					holder = new TradeEntry(trade.getOrder().getBrokerID(), trade.getOrder().getInstrument());
					getTradeExch().put(key, holder);
				}
				holder.addTrade(trade);
				
				warn("PosRun Order=" + trade.getOrder());
				sendOrder(trade.getOrder());
			}
			
			Reason reason = Reason.SYNC_TRADES;
	        requestCallbackAfter(reason.getDelay(), reason);
			warn("PosRun: PnL=" + posPnL + "; Entries=" + Arrays.toString(posTrades.toArray()));
			return;
		}    	
		
		mStrategyMode = StrategyMode.TR_POSRUN;
	    if(posPnL > 0){//TODO
    		mCounter++; mPnL += posPnL;
    		System.out.println("PositivePos: " + mCounter + "; TPnL=" + mPnL + "; PnL=" + posPnL + "; Entries=" + Arrays.toString(posTrades.toArray()));
		}
    }
    
    /**
     * Manage trades still open or rejected
     */
    private void tradeOpsRun()
    {
    	mStrategyMode = StrategyMode.TR_HALT;
    	
		//Follow-up open trades
    	List<ITradeSide> opsTrades = Lists.newArrayList();
		for(ITradeEntry holder:getTradeExch().values()){
			for(Iterator<ITradeSide> it = holder.getTrades().iterator(); it.hasNext();){
				ITradeSide trade = it.next();
				OrderSingle order = trade.getOrder();
				
				//Get the size
				double tradeSz = trade.getLeavesQty();
				
				if(trade.isOpened()){
					if(trade.isBuy()){
						IMarketSide ask = trade.getMarket().getAsk();
						if(((trade.getMarket().getScore() > TRADE_SCORE_THRESHOLD)  || //go Long
								(order.getPrice().doubleValue() < ask.getRefPz()*(1 - TRADE_STOPLOSS_THRESHOLD)))
								&& ask.getSize() >= tradeSz)//check stop loss
						{
    						//move trade to market
							holder.remove(trade);
							cancelOrder(order.getOrderID(), true);
							opsTrades.addAll(ask.execute(tradeSz, getIDSuffix()));
							warn("Move trade to market-Long: " + order.getOrderID() + "; score: " + Math.round(trade.getMarket().getScore()*100.)/100. + "; " + order.getPrice() + " vs " + ask.getRefPz());
    					}
					}else{
						IMarketSide bid = trade.getMarket().getBid();
						if(((trade.getMarket().getScore() < 1 - TRADE_SCORE_THRESHOLD) || //go short
								(order.getPrice().doubleValue() >bid.getRefPz()*(1 + TRADE_STOPLOSS_THRESHOLD)))
								&& bid.getSize() >= tradeSz)//check stop loss
						{
    						//move trade to market
							holder.remove(trade);
							cancelOrder(order.getOrderID(), true);
							opsTrades.addAll(bid.execute(tradeSz, getIDSuffix()));
							warn("Move trade to market-Short: " + order.getOrderID() + "; score: " + Math.round(trade.getMarket().getScore()*100.)/100. + "; " + order.getPrice() + " vs " + bid.getRefPz());
    					}
					}
				} else if(trade.isRejected()){
					if(trade.isBuy())
					{
						IMarketSide ask = trade.getMarket().getAsk();
						if(ask.getSize() >= tradeSz)
						{
							holder.remove(trade);
							opsTrades.addAll(ask.execute(tradeSz, getIDSuffix()));
							warn("Rejected Re-Entry Long: " + order.getOrderID() + "; score: " + Math.round(trade.getMarket().getScore()*100.)/100. + "; " + order.getPrice() + " vs " + ask.getRefPz());
						}
					}else{
						IMarketSide bid = trade.getMarket().getBid();
						if(bid.getSize() >= tradeSz)
						{
							holder.remove(trade);
							opsTrades.addAll(bid.execute(tradeSz, getIDSuffix()));
							warn("Rejected Re-Entry Short: " + order.getOrderID() + "; score: " + Math.round(trade.getMarket().getScore()*100.)/100. + "; " + order.getPrice() + " vs " + bid.getRefPz());
						}
					}
				}
			}
		}
		
		//Manage Open/Reject trades
		if(!opsTrades.isEmpty()){
			for(ITradeSide trade:opsTrades){
				DataReferenceKey key = DataKeyFactory.createKey(trade);
				ITradeEntry holder = getTradeExch().get(key);
				if(holder == null){
					holder = new TradeEntry(trade.getOrder().getBrokerID(), trade.getOrder().getInstrument());
					getTradeExch().put(key, holder);
				}
				holder.addTrade(trade);
				
				warn("OpsRun Order=" + trade.getOrder());
				sendOrder(trade.getOrder());
			}
			
			Reason reason = Reason.SYNC_TRADES;
	        requestCallbackAfter(reason.getDelay(), reason);
	        System.out.println("OpsRun Entries=" + Arrays.toString(opsTrades.toArray()));
			return;
		}
		
		onCallback(Reason.SYNC_TRADES);
    }
    
    /**
	 * Returns the standard size of a trade
	 * 
	 * @param symbol the trade symbol
	 * 
	 * @return the size
	 */
	private double getStandardSize(String symbol) 
	{
		/*Double tradeSz = getSizeCache().get(symbol);
		if(tradeSz == null){
			IMarketEntry instMarket = getMarketArbs().get(symbol);
			if(instMarket != null){
				tradeSz = Math.max(TRADE_MAX_NOTIONAL / instMarket.getAsk().getPrice(), 1.);
				getSizeCache().put(symbol, tradeSz);
			}else{
				tradeSz = 1.;
				warn("The following instrument: " + symbol + ", has no nominal value size, default size is: 1.");
			}
		}*/
		if(symbol.equals("BRENT") || symbol.equals("WTI")){
			return 100.;
		}
		return 10.;
		
		//return TRADE_MAX_SIZE;
	}

		
    /**
     * Executed when the strategy receives a callback requested via
     * {@link #requestCallbackAt(java.util.Date, Object)} or
     * {@link #requestCallbackAfter(long, Object)}. All timer
     * callbacks come with the data supplied when requesting callback,
     * as an argument.
     *
     * @param inData the callback data
     */
    @Override
    public void onCallback(Object inData) 
    {
    	if(inData == null)
    		return;
    	
    	if(inData.equals(Reason.MD_UPDATE))
    	{	 
    		StrategyMode mode = mStrategyMode;
    		mStrategyMode = StrategyMode.TR_HALT;
			for(IBrokerEntry market: getDataExch().values()){
				market.onCallback();
			}
			mStrategyMode = mode;
    	} else if(inData.equals(Reason.SYNC_TRADES))
    	{
    		mStrategyMode = StrategyMode.TR_HALT;
    		
    		int maxPosition = 0; boolean maxActive = false;
    		for(ITradeEntry holder:getTradeExch().values()){
    			if(holder.getActiveNB() > 0){
    				maxActive = true;
    				break;
    			}
    			maxPosition = Math.max(maxPosition, holder.getFilledNB());
    		}
   			
    		//Trade mode initiated
    		if(maxActive){
    			mStrategyMode = StrategyMode.TR_OPSRUN;
    		}else{
    			if(maxPosition >= TRADE_MAX_POSNB){
    				notifyHigh("Strategy-" + STRATEGY_SUFFIX, "Entry for position runs.");
	    			mStrategyMode = StrategyMode.TR_POSRUN;
	    			mExecutionMode.set(false);
	    		}else if(maxPosition == 0){
	    			notifyHigh("Strategy-" + STRATEGY_SUFFIX, "Optimal runs initiated.");
	    			mStrategyMode = StrategyMode.TR_OPTRUN;
	    			mExecutionMode.set(true);
	    		} else{
		    		if(mExecutionMode.get()){
		    			mStrategyMode = StrategyMode.TR_OPTRUN;
		    		}else{
		    			mStrategyMode = StrategyMode.TR_POSRUN;
		    		}
	    		}
    		}
    	} else if(inData.equals(Reason.TECH_INIT)){            
            onCallback(Reason.MD_UPDATE);
            onCallback(Reason.SYNC_TRADES);
			
            //Setup market data init 
            Reason reason = Reason.MD_UPDATE;
            requestCallbackEvery(reason.getDelay(), reason.getDelay(), reason);
    	}
    }
    
    /**
     * Executed when the strategy receives an execution report.
     *
     * @param inReport the execution report.
     */
    @Override
    public void onExecutionReport(ExecutionReport inReport) 
    {
    	warn("Received Execution Report:" + inReport);
        
        DataReferenceKey key = DataKeyFactory.createKey(inReport);
		ITradeEntry holder = getTradeExch().get(key);
		if(holder != null){
			holder.onReport(inReport);
		}
    }
    
    /**
     * Indicates an <code>OrderCancelReject</code> has been received.
     *
     * @param inCancelReject an <code>OrderCancelReject</code> value
     */
    @Override
    public void onCancelReject(OrderCancelReject inCancelReject)
    {
    	/*warn("Cancel Reject:" + inCancelReject);
    	
    	OrderID id = getRootOrderID(inCancelReject.getOrderID());
		Deque<ReportBase> rawData = getExecutionReports(id);
		for(Iterator<ReportBase> it = rawData.descendingIterator(); it.hasNext();){
			ReportBase report = it.next();
			if(report instanceof ExecutionReport){
				onExecutionReport((ExecutionReport) report);
				break;
			}
		}*/
    }
    
    /**
     * Executed when the strategy is stopped.
     */
    @Override
    public void onStop() 
    {
        warn("ArbStrategy Stoping...!");
    }
}
